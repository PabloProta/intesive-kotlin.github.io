---
layout: default
parent: Collections
title: Sequences
nav_order: 2
---
<script src="https://unpkg.com/kotlin-playground@1" data-selector="code"></script>
# 🤔  What are Sequences in Kotlin?

In Kotlin, sequences are a type of collection that allows you to process large data sets efficiently. They're similar to lists, but with some cool advantages.

## 🔍 What are the advantages of Sequences?

🚀 They're lazy, which means they don't compute all their elements immediately. This can save a lot of time and memory when dealing with large data sets.

💪 They're also chainable, which means you can perform multiple operations on them in a single pass. This can make your code cleaner and more concise.

## 🙌 How do I create a Sequence in Kotlin?

To create a sequence in Kotlin, you can use the sequenceOf() function. This function takes any number of elements and returns a sequence.

```run-kotlin
fun main(){
    val sequence = sequenceOf(1, 2, 3, 4, 5)
}
```
## 🤓 How do I work with Sequences in Kotlin?

Once you have a sequence, you can perform operations on it using functions like map(), filter(), and reduce(). These functions allow you to transform, filter, and aggregate the elements in the sequence.

For example, let's say you have a sequence of numbers and you want to double each number, then filter out the even numbers, and finally sum the remaining numbers.

```run-kotlin
fun main(){
    val sequence = sequenceOf(1, 2, 3, 4, 5)

    val result = sequence
        .map { it * 2 }  // double each number
        .filter { it % 2 != 0 }  // filter out the even numbers
        .sum()  // sum the remaining numbers

    println(result)  // output: 18
}
```
## 😂 Let's Recap

There's another way to declare a sequence in Kotlin, which is by using the sequence builder function. This allows you to define a sequence using a block of code, similar to how you would define a function using a lambda expression.

For example, to create a sequence of strings in reverse order, you could use the following code:

```run-kotlin
fun main() {
    val reverseStrings = sequence {
        val words = listOf("hello", "world", "Kotlin", "sequences")
        for (i in words.indices.reversed()) {
            yield(words[i])
        }
    }


    println(reverseStrings)
}


```
In this example, the sequence function creates a new sequence, and the code block inside the function defines the sequence elements using a for loop and the yield() function. The yield() function adds an element to the sequence, and the indices.reversed() function is used to iterate over the list of words in reverse order.

And just like with other sequences, this new sequence will only evaluate elements as they are needed, making it an efficient way to work with large collections of data. 🧬

So, now you know three different ways to declare a sequence in Kotlin - using sequenceOf(), generateSequence(), or the sequence builder function. Happy coding! 👨‍💻

## Real usage

So, picture this: You're a programmer and you've been tasked with processing a massive amount of data for an online store. 😱

But fear not, my friend! Kotlin Sequence is here to save the day. 🤖💪

Instead of panicking and trying to process all of that data at once, you can use Kotlin Sequence to efficiently iterate over each element and only evaluate the data when needed. It's a lazy but efficient approach that can save you time and resources. Plus, who doesn't love a little laziness every now and then? 😜

For example, you can use a sequence to filter out incomplete customer orders and calculate the total revenue generated by the first 100 complete orders:

```run-kotlin
val customerOrders = // some large data set of customer orders

val orderTotalSequence = customerOrders.asSequence()
    .filter { it.status == "complete" }
    .map { it.calculateOrderTotal() }
    .take(100)
```

val totalRevenue = orderTotalSequence.sum()
And just like that, you've processed a massive amount of data with ease and efficiency, all thanks to our hero Kotlin Sequence. 😎🙌

In summary, Kotlin Sequence is a powerful and efficient tool for working with large collections of data. By using a sequence, you can iterate over each element and only evaluate the data when needed, saving time and resources. Plus, it's a little lazy, but who doesn't love a little bit of laziness every now and then? 😜